{"ast":null,"code":"/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\nvar ENCODE_AUTO = 'auto';\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof latitude === 'number' || typeof longitude === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n  var chars = [],\n    bits = 0,\n    bitsTotal = 0,\n    hash_value = 0,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n  bitDepth = bitDepth || 52;\n  var bitsTotal = 0,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid,\n    combinedBits = 0;\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = hashValue >> bits & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n  bitDepth = bitDepth || 52;\n  var maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON;\n  var latBit = 0,\n    lonBit = 0;\n  var step = bitDepth / 2;\n  for (var i = 0; i < step; i++) {\n    lonBit = get_bit(hashInt, (step - i) * 2 - 1);\n    latBit = get_bit(hashInt, (step - i) * 2 - 2);\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    } else {\n      minLat = (maxLat + minLat) / 2;\n    }\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    } else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\nfunction get_bit(bits, position) {\n  return bits / Math.pow(2, position) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {\n    latitude: lat,\n    longitude: lon,\n    error: {\n      latitude: latErr,\n      longitude: lonErr\n    }\n  };\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {\n    latitude: lat,\n    longitude: lon,\n    error: {\n      latitude: latErr,\n      longitude: lonErr\n    }\n  };\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n  bitDepth = bitDepth || 52;\n  var lonlat = decode_int(hash_int, bitDepth);\n  var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n  var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n  neighbor_lon = ensure_valid_lon(neighbor_lon);\n  neighbor_lat = ensure_valid_lat(neighbor_lat);\n  return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n  var hashstringLength = hash_string.length;\n  var lonlat = decode(hash_string);\n  var lat = lonlat.latitude;\n  var lon = lonlat.longitude;\n  var latErr = lonlat.error.latitude * 2;\n  var lonErr = lonlat.error.longitude * 2;\n  var neighbor_lat, neighbor_lon;\n  var neighborHashList = [encodeNeighbor(1, 0), encodeNeighbor(1, 1), encodeNeighbor(0, 1), encodeNeighbor(-1, 1), encodeNeighbor(-1, 0), encodeNeighbor(-1, -1), encodeNeighbor(0, -1), encodeNeighbor(1, -1)];\n  function encodeNeighbor(neighborLatDir, neighborLonDir) {\n    neighbor_lat = lat + neighborLatDir * latErr;\n    neighbor_lon = lon + neighborLonDir * lonErr;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode(neighbor_lat, neighbor_lon, hashstringLength);\n  }\n  return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function (hash_int, bitDepth) {\n  bitDepth = bitDepth || 52;\n  var lonlat = decode_int(hash_int, bitDepth);\n  var lat = lonlat.latitude;\n  var lon = lonlat.longitude;\n  var latErr = lonlat.error.latitude * 2;\n  var lonErr = lonlat.error.longitude * 2;\n  var neighbor_lat, neighbor_lon;\n  var neighborHashIntList = [encodeNeighbor_int(1, 0), encodeNeighbor_int(1, 1), encodeNeighbor_int(0, 1), encodeNeighbor_int(-1, 1), encodeNeighbor_int(-1, 0), encodeNeighbor_int(-1, -1), encodeNeighbor_int(0, -1), encodeNeighbor_int(1, -1)];\n  function encodeNeighbor_int(neighborLatDir, neighborLonDir) {\n    neighbor_lat = lat + neighborLatDir * latErr;\n    neighbor_lon = lon + neighborLonDir * lonErr;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n  }\n  return neighborHashIntList;\n};\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n  var latLon = decode(hashSouthWest);\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n  var hashList = [];\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function (minLat, minLon, maxLat, maxLon, bitDepth) {\n  bitDepth = bitDepth || 52;\n  var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n  var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n  var latlon = decode_int(hashSouthWest, bitDepth);\n  var perLat = latlon.error.latitude * 2;\n  var perLon = latlon.error.longitude * 2;\n  var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n  var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n  var hashList = [];\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor_int(hashSouthWest, [lat, lon], bitDepth));\n    }\n  }\n  return hashList;\n};\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON) return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON) return MAX_LON + lon % MAX_LON;\n  return lon;\n}\n;\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT) return MAX_LAT;\n  if (lat < MIN_LAT) return MIN_LAT;\n  return lat;\n}\n;\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int,\n  // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int,\n  // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int,\n  // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\nmodule.exports = geohash;","map":{"version":3,"names":["BASE32_CODES","BASE32_CODES_DICT","i","length","charAt","ENCODE_AUTO","MIN_LAT","MAX_LAT","MIN_LON","MAX_LON","SIGFIG_HASH_LENGTH","encode","latitude","longitude","numberOfChars","Error","decSigFigsLat","split","decSigFigsLong","numberOfSigFigs","Math","max","undefined","chars","bits","bitsTotal","hash_value","maxLat","minLat","maxLon","minLon","mid","code","push","join","encode_int","bitDepth","combinedBits","decode_bbox","hash_string","isLon","hashValue","l","toLowerCase","bit","decode_bbox_int","hashInt","latBit","lonBit","step","get_bit","position","pow","decode","hashString","bbox","lat","lon","latErr","lonErr","error","decode_int","hash_int","neighbor","direction","lonLat","neighborLat","neighborLon","ensure_valid_lon","ensure_valid_lat","neighbor_int","lonlat","neighbor_lat","neighbor_lon","neighbors","hashstringLength","neighborHashList","encodeNeighbor","neighborLatDir","neighborLonDir","neighbors_int","neighborHashIntList","encodeNeighbor_int","bboxes","hashSouthWest","hashNorthEast","latLon","perLat","perLon","boxSouthWest","boxNorthEast","latStep","round","lonStep","hashList","bboxes_int","latlon","geohash","module","exports"],"sources":["/Users/dhruv/node_modules/ngeohash/main.js"],"sourcesContent":["/**\n * Copyright (c) 2011, Sun Ning.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use, copy,\n * modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n */\n\nvar BASE32_CODES = \"0123456789bcdefghjkmnpqrstuvwxyz\";\nvar BASE32_CODES_DICT = {};\nfor (var i = 0; i < BASE32_CODES.length; i++) {\n  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;\n}\n\nvar ENCODE_AUTO = 'auto';\n\nvar MIN_LAT = -90;\nvar MAX_LAT = 90;\nvar MIN_LON = -180;\nvar MAX_LON = 180;\n/**\n * Significant Figure Hash Length\n *\n * This is a quick and dirty lookup to figure out how long our hash\n * should be in order to guarantee a certain amount of trailing\n * significant figures. This was calculated by determining the error:\n * 45/2^(n-1) where n is the number of bits for a latitude or\n * longitude. Key is # of desired sig figs, value is minimum length of\n * the geohash.\n * @type Array\n */\n//     Desired sig figs:  0  1  2  3  4   5   6   7   8   9  10\nvar SIGFIG_HASH_LENGTH = [0, 5, 7, 8, 11, 12, 13, 15, 16, 17, 18];\n/**\n * Encode\n *\n * Create a Geohash out of a latitude and longitude that is\n * `numberOfChars` long.\n *\n * @param {Number|String} latitude\n * @param {Number|String} longitude\n * @param {Number} numberOfChars\n * @returns {String}\n */\nvar encode = function (latitude, longitude, numberOfChars) {\n  if (numberOfChars === ENCODE_AUTO) {\n    if (typeof(latitude) === 'number' || typeof(longitude) === 'number') {\n      throw new Error('string notation required for auto precision.');\n    }\n    var decSigFigsLat = latitude.split('.')[1].length;\n    var decSigFigsLong = longitude.split('.')[1].length;\n    var numberOfSigFigs = Math.max(decSigFigsLat, decSigFigsLong);\n    numberOfChars = SIGFIG_HASH_LENGTH[numberOfSigFigs];\n  } else if (numberOfChars === undefined) {\n    numberOfChars = 9;\n  }\n\n  var chars = [],\n  bits = 0,\n  bitsTotal = 0,\n  hash_value = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid;\n  while (chars.length < numberOfChars) {\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLon = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        hash_value = (hash_value << 1) + 1;\n        minLat = mid;\n      } else {\n        hash_value = (hash_value << 1) + 0;\n        maxLat = mid;\n      }\n    }\n\n    bits++;\n    bitsTotal++;\n    if (bits === 5) {\n      var code = BASE32_CODES[hash_value];\n      chars.push(code);\n      bits = 0;\n      hash_value = 0;\n    }\n  }\n  return chars.join('');\n};\n\n/**\n * Encode Integer\n *\n * Create a Geohash out of a latitude and longitude that is of 'bitDepth'.\n *\n * @param {Number} latitude\n * @param {Number} longitude\n * @param {Number} bitDepth\n * @returns {Number}\n */\nvar encode_int = function (latitude, longitude, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var bitsTotal = 0,\n  maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON,\n  mid,\n  combinedBits = 0;\n\n  while (bitsTotal < bitDepth) {\n    combinedBits *= 2;\n    if (bitsTotal % 2 === 0) {\n      mid = (maxLon + minLon) / 2;\n      if (longitude > mid) {\n        combinedBits += 1;\n        minLon = mid;\n      } else {\n        maxLon = mid;\n      }\n    } else {\n      mid = (maxLat + minLat) / 2;\n      if (latitude > mid) {\n        combinedBits += 1;\n        minLat = mid;\n      } else {\n        maxLat = mid;\n      }\n    }\n    bitsTotal++;\n  }\n  return combinedBits;\n};\n\n/**\n * Decode Bounding Box\n *\n * Decode hashString into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {String} hash_string\n * @returns {Array}\n */\nvar decode_bbox = function (hash_string) {\n  var isLon = true,\n    maxLat = MAX_LAT,\n    minLat = MIN_LAT,\n    maxLon = MAX_LON,\n    minLon = MIN_LON,\n    mid;\n\n  var hashValue = 0;\n  for (var i = 0, l = hash_string.length; i < l; i++) {\n    var code = hash_string[i].toLowerCase();\n    hashValue = BASE32_CODES_DICT[code];\n\n    for (var bits = 4; bits >= 0; bits--) {\n      var bit = (hashValue >> bits) & 1;\n      if (isLon) {\n        mid = (maxLon + minLon) / 2;\n        if (bit === 1) {\n          minLon = mid;\n        } else {\n          maxLon = mid;\n        }\n      } else {\n        mid = (maxLat + minLat) / 2;\n        if (bit === 1) {\n          minLat = mid;\n        } else {\n          maxLat = mid;\n        }\n      }\n      isLon = !isLon;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\n/**\n * Decode Bounding Box Integer\n *\n * Decode hash number into a bound box matches it. Data returned in a four-element array: [minlat, minlon, maxlat, maxlon]\n * @param {Number} hashInt\n * @param {Number} bitDepth\n * @returns {Array}\n */\nvar decode_bbox_int = function (hashInt, bitDepth) {\n\n  bitDepth = bitDepth || 52;\n\n  var maxLat = MAX_LAT,\n  minLat = MIN_LAT,\n  maxLon = MAX_LON,\n  minLon = MIN_LON;\n\n  var latBit = 0, lonBit = 0;\n  var step = bitDepth / 2;\n\n  for (var i = 0; i < step; i++) {\n\n    lonBit = get_bit(hashInt, ((step - i) * 2) - 1);\n    latBit = get_bit(hashInt, ((step - i) * 2) - 2);\n\n    if (latBit === 0) {\n      maxLat = (maxLat + minLat) / 2;\n    }\n    else {\n      minLat = (maxLat + minLat) / 2;\n    }\n\n    if (lonBit === 0) {\n      maxLon = (maxLon + minLon) / 2;\n    }\n    else {\n      minLon = (maxLon + minLon) / 2;\n    }\n  }\n  return [minLat, minLon, maxLat, maxLon];\n};\n\nfunction get_bit(bits, position) {\n  return (bits / Math.pow(2, position)) & 0x01;\n}\n\n/**\n * Decode\n *\n * Decode a hash string into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {String} hashString\n * @returns {Object}\n */\nvar decode = function (hashString) {\n  var bbox = decode_bbox(hashString);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n      error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Decode Integer\n *\n * Decode a hash number into pair of latitude and longitude. A javascript object is returned with keys `latitude`,\n * `longitude` and `error`.\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {Object}\n */\nvar decode_int = function (hash_int, bitDepth) {\n  var bbox = decode_bbox_int(hash_int, bitDepth);\n  var lat = (bbox[0] + bbox[2]) / 2;\n  var lon = (bbox[1] + bbox[3]) / 2;\n  var latErr = bbox[2] - lat;\n  var lonErr = bbox[3] - lon;\n  return {latitude: lat, longitude: lon,\n          error: {latitude: latErr, longitude: lonErr}};\n};\n\n/**\n * Neighbor\n *\n * Find neighbor of a geohash string in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hashString\n * @param {Array} Direction as a 2D normalized vector.\n * @returns {String}\n */\nvar neighbor = function (hashString, direction) {\n  var lonLat = decode(hashString);\n  var neighborLat = lonLat.latitude\n    + direction[0] * lonLat.error.latitude * 2;\n  var neighborLon = lonLat.longitude\n    + direction[1] * lonLat.error.longitude * 2;\n  neighborLon = ensure_valid_lon(neighborLon);\n  neighborLat = ensure_valid_lat(neighborLat);\n  return encode(neighborLat, neighborLon, hashString.length);\n};\n\n/**\n * Neighbor Integer\n *\n * Find neighbor of a geohash integer in certain direction. Direction is a two-element array, i.e. [1,0] means north, [-1,-1] means southwest.\n * direction [lat, lon], i.e.\n * [1,0] - north\n * [1,1] - northeast\n * ...\n * @param {String} hash_string\n * @returns {Array}\n*/\nvar neighbor_int = function (hash_int, direction, bitDepth) {\n    bitDepth = bitDepth || 52;\n    var lonlat = decode_int(hash_int, bitDepth);\n    var neighbor_lat = lonlat.latitude + direction[0] * lonlat.error.latitude * 2;\n    var neighbor_lon = lonlat.longitude + direction[1] * lonlat.error.longitude * 2;\n    neighbor_lon = ensure_valid_lon(neighbor_lon);\n    neighbor_lat = ensure_valid_lat(neighbor_lat);\n    return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n};\n\n/**\n * Neighbors\n *\n * Returns all neighbors' hashstrings clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {String} hash_string\n * @returns {encoded neighborHashList|Array}\n */\nvar neighbors = function (hash_string) {\n\n    var hashstringLength = hash_string.length;\n\n    var lonlat = decode(hash_string);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashList = [\n                            encodeNeighbor(1,0),\n                            encodeNeighbor(1,1),\n                            encodeNeighbor(0,1),\n                            encodeNeighbor(-1,1),\n                            encodeNeighbor(-1,0),\n                            encodeNeighbor(-1,-1),\n                            encodeNeighbor(0,-1),\n                            encodeNeighbor(1,-1)\n                            ];\n\n    function encodeNeighbor(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode(neighbor_lat, neighbor_lon, hashstringLength);\n    }\n\n    return neighborHashList;\n};\n\n/**\n * Neighbors Integer\n *\n * Returns all neighbors' hash integers clockwise from north around to northwest\n * 7 0 1\n * 6 x 2\n * 5 4 3\n * @param {Number} hash_int\n * @param {Number} bitDepth\n * @returns {encode_int'd neighborHashIntList|Array}\n */\nvar neighbors_int = function(hash_int, bitDepth){\n\n    bitDepth = bitDepth || 52;\n\n    var lonlat = decode_int(hash_int, bitDepth);\n    var lat = lonlat.latitude;\n    var lon = lonlat.longitude;\n    var latErr = lonlat.error.latitude * 2;\n    var lonErr = lonlat.error.longitude * 2;\n\n    var neighbor_lat,\n        neighbor_lon;\n\n    var neighborHashIntList = [\n                               encodeNeighbor_int(1,0),\n                               encodeNeighbor_int(1,1),\n                               encodeNeighbor_int(0,1),\n                               encodeNeighbor_int(-1,1),\n                               encodeNeighbor_int(-1,0),\n                               encodeNeighbor_int(-1,-1),\n                               encodeNeighbor_int(0,-1),\n                               encodeNeighbor_int(1,-1)\n                               ];\n\n    function encodeNeighbor_int(neighborLatDir, neighborLonDir){\n        neighbor_lat = lat + neighborLatDir * latErr;\n        neighbor_lon = lon + neighborLonDir * lonErr;\n        neighbor_lon = ensure_valid_lon(neighbor_lon);\n        neighbor_lat = ensure_valid_lat(neighbor_lat);\n        return encode_int(neighbor_lat, neighbor_lon, bitDepth);\n    }\n\n    return neighborHashIntList;\n};\n\n\n/**\n * Bounding Boxes\n *\n * Return all the hashString between minLat, minLon, maxLat, maxLon in numberOfChars\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} numberOfChars\n * @returns {bboxes.hashList|Array}\n */\nvar bboxes = function (minLat, minLon, maxLat, maxLon, numberOfChars) {\n  numberOfChars = numberOfChars || 9;\n\n  var hashSouthWest = encode(minLat, minLon, numberOfChars);\n  var hashNorthEast = encode(maxLat, maxLon, numberOfChars);\n\n  var latLon = decode(hashSouthWest);\n\n  var perLat = latLon.error.latitude * 2;\n  var perLon = latLon.error.longitude * 2;\n\n  var boxSouthWest = decode_bbox(hashSouthWest);\n  var boxNorthEast = decode_bbox(hashNorthEast);\n\n  var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0]) / perLat);\n  var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1]) / perLon);\n\n  var hashList = [];\n\n  for (var lat = 0; lat <= latStep; lat++) {\n    for (var lon = 0; lon <= lonStep; lon++) {\n      hashList.push(neighbor(hashSouthWest, [lat, lon]));\n    }\n  }\n\n  return hashList;\n};\n\n/**\n * Bounding Boxes Integer\n *\n * Return all the hash integers between minLat, minLon, maxLat, maxLon in bitDepth\n * @param {Number} minLat\n * @param {Number} minLon\n * @param {Number} maxLat\n * @param {Number} maxLon\n * @param {Number} bitDepth\n * @returns {bboxes_int.hashList|Array}\n */\nvar bboxes_int = function(minLat, minLon, maxLat, maxLon, bitDepth){\n    bitDepth = bitDepth || 52;\n\n    var hashSouthWest = encode_int(minLat, minLon, bitDepth);\n    var hashNorthEast = encode_int(maxLat, maxLon, bitDepth);\n\n    var latlon = decode_int(hashSouthWest, bitDepth);\n\n    var perLat = latlon.error.latitude * 2;\n    var perLon = latlon.error.longitude * 2;\n\n    var boxSouthWest = decode_bbox_int(hashSouthWest, bitDepth);\n    var boxNorthEast = decode_bbox_int(hashNorthEast, bitDepth);\n\n    var latStep = Math.round((boxNorthEast[0] - boxSouthWest[0])/perLat);\n    var lonStep = Math.round((boxNorthEast[1] - boxSouthWest[1])/perLon);\n\n    var hashList = [];\n\n    for(var lat = 0; lat <= latStep; lat++){\n        for(var lon = 0; lon <= lonStep; lon++){\n            hashList.push(neighbor_int(hashSouthWest,[lat, lon], bitDepth));\n        }\n    }\n\n  return hashList;\n};\n\nfunction ensure_valid_lon(lon) {\n  if (lon > MAX_LON)\n    return MIN_LON + lon % MAX_LON;\n  if (lon < MIN_LON)\n    return MAX_LON + lon % MAX_LON;\n  return lon;\n};\n\nfunction ensure_valid_lat(lat) {\n  if (lat > MAX_LAT)\n    return MAX_LAT;\n  if (lat < MIN_LAT)\n    return MIN_LAT;\n  return lat;\n};\n\nvar geohash = {\n  'ENCODE_AUTO': ENCODE_AUTO,\n  'encode': encode,\n  'encode_uint64': encode_int, // keeping for backwards compatibility, will deprecate\n  'encode_int': encode_int,\n  'decode': decode,\n  'decode_int': decode_int,\n  'decode_uint64': decode_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox': decode_bbox,\n  'decode_bbox_uint64': decode_bbox_int, // keeping for backwards compatibility, will deprecate\n  'decode_bbox_int': decode_bbox_int,\n  'neighbor': neighbor,\n  'neighbor_int': neighbor_int,\n  'neighbors': neighbors,\n  'neighbors_int': neighbors_int,\n  'bboxes': bboxes,\n  'bboxes_int': bboxes_int\n};\n\nmodule.exports = geohash;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}